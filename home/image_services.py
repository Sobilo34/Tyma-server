from typing import Optional, List, Union
from uuid import UUID
from django.db.models import QuerySet
from django.contrib.contenttypes.models import ContentType
from django.core.files.uploadedfile import InMemoryUploadedFile, TemporaryUploadedFile
import traceback
from .models import TYMAImage
from .schemas import (
    HTTPStatusCode,
    StandardResponseDTO,
    TYMAImageOut,
    PaginatedResponseSchema,
    TYMAImageCreateSchema,
    TYMAImageUpdateSchema
)
from django.core.exceptions import ObjectDoesNotExist
import os
from django.conf import settings


def create_detailed_error_response(exception: Exception, operation: str) -> str:
    """Create detailed error message with traceback for debugging"""
    error_details = f"Error during {operation}: {str(exception)}"
    if hasattr(exception, '__traceback__'):
        error_details += f"\nTraceback: {traceback.format_exc()}"
    return error_details


class ImageService:
    @staticmethod
    def _image_to_schema(image: TYMAImage) -> TYMAImageOut:
        """Convert TYMAImage model instance to TYMAImageOut schema"""
        return TYMAImageOut(
            id=image.id,
            title=image.title,
            url=image.get_image_url(),
            alt_text=image.alt_text,
            caption=image.caption,
            image_type=image.image_type,
            content_type=image.content_type.model if image.content_type else None,
            object_id=str(image.object_id) if image.object_id else None,
            created_at=image.created_at,
            updated_at=image.updated_at
        )

    @staticmethod
    def _get_paginated_response(
        queryset: QuerySet,
        page: int,
        per_page: int,
        schema_converter
    ) -> PaginatedResponseSchema:
        """Generic pagination helper with error handling"""
        try:
            # Ensure page and per_page are positive
            page = max(1, page)
            per_page = max(1, min(per_page, 100))  # Cap at 100 items per page
            
            offset = (page - 1) * per_page
            total = queryset.count()
            
            # Check if page number is valid
            if offset >= total and total > 0:
                # Return last valid page instead of empty result
                last_page = (total - 1) // per_page + 1
                offset = (last_page - 1) * per_page
                page = last_page
            
            items = queryset[offset:offset + per_page]
            return PaginatedResponseSchema(
                items=[schema_converter(item) for item in items],
                total=total,
                page=page,
                per_page=per_page
            )
        except Exception as e:
            # Return empty pagination result on error
            return PaginatedResponseSchema(
                items=[],
                total=0,
                page=1,
                per_page=per_page
            )

    @staticmethod
    def create_image(
        image_file: Union[InMemoryUploadedFile, TemporaryUploadedFile],
        title: str = None,
        alt_text: str = None,
        caption: str = None,
        image_type: str = 'OTHER',
        content_type_id: int = None
    ) -> StandardResponseDTO[TYMAImageOut]:
        """Create a new image"""
        try:
            # Validate image type
            valid_types = [choice[0] for choice in TYMAImage.IMAGE_TYPE_CHOICES]
            if image_type not in valid_types:
                return StandardResponseDTO[TYMAImageOut](
                    data=None,
                    status_code=HTTPStatusCode.BAD_REQUEST,
                    success=False,
                    message=f"Invalid image type. Must be one of: {valid_types}"
                )

            # Get content type if provided
            content_type = None
            if content_type_id:
                try:
                    content_type = ContentType.objects.get(id=content_type_id)
                except ContentType.DoesNotExist:
                    return StandardResponseDTO[TYMAImageOut](
                        data=None,
                        status_code=HTTPStatusCode.BAD_REQUEST,
                        success=False,
                        message="Invalid content type ID"
                    )

            # Create the image (object_id will be auto-generated by the model if needed)
            image = TYMAImage.objects.create(
                title=title or image_file.name,
                image=image_file,
                alt_text=alt_text or "",
                caption=caption or "",
                image_type=image_type,
                content_type=content_type
                # object_id is intentionally omitted - will remain None unless auto-generated in future
            )
            
            return StandardResponseDTO[TYMAImageOut](
                data=ImageService._image_to_schema(image),
                status_code=HTTPStatusCode.CREATED,
                message="Image created successfully"
            )
        except Exception as e:
            error_message = create_detailed_error_response(e, "image creation")
            return StandardResponseDTO[TYMAImageOut](
                data=None,
                status_code=HTTPStatusCode.INTERNAL_SERVER_ERROR,
                success=False,
                message=error_message
            )

    @staticmethod
    def get_image(image_id: str) -> StandardResponseDTO[TYMAImageOut]:
        """Get a single image by ID"""
        try:
            image = TYMAImage.objects.get(id=UUID(image_id))
            return StandardResponseDTO[TYMAImageOut](
                data=ImageService._image_to_schema(image),
                status_code=HTTPStatusCode.OK,
                success=True,
                message="Image retrieved successfully"
            )
        except (ValueError, TYMAImage.DoesNotExist):
            return StandardResponseDTO[TYMAImageOut](
                data=None,
                status_code=HTTPStatusCode.NOT_FOUND,
                success=False,
                message=f"Image with ID '{image_id}' not found"
            )
        except Exception as e:
            error_message = create_detailed_error_response(e, "image retrieval")
            return StandardResponseDTO[TYMAImageOut](
                data=None,
                status_code=HTTPStatusCode.INTERNAL_SERVER_ERROR,
                success=False,
                message=error_message
            )

    @staticmethod
    def get_all_images(
        page: int = 1,
        per_page: int = 10,
        image_type: str = None,
        content_type: str = None,
        object_id: str = None
    ) -> StandardResponseDTO[PaginatedResponseSchema[TYMAImageOut]]:
        """Get all images with optional filters (paginated)"""
        try:
            queryset = TYMAImage.objects.all()
            
            # Apply filters
            if image_type:
                queryset = queryset.filter(image_type=image_type)
            
            if content_type and object_id:
                try:
                    ct = ContentType.objects.get(model=content_type)
                    queryset = queryset.filter(content_type=ct, object_id=UUID(object_id))
                except (ContentType.DoesNotExist, ValueError):
                    return StandardResponseDTO[PaginatedResponseSchema[TYMAImageOut]](
                        data=PaginatedResponseSchema(items=[], total=0, page=1, per_page=per_page),
                        status_code=HTTPStatusCode.BAD_REQUEST,
                        success=False,
                        message="Invalid content type or object ID"
                    )
            
            paginated_data = ImageService._get_paginated_response(
                queryset, page, per_page, ImageService._image_to_schema
            )
            
            return StandardResponseDTO[PaginatedResponseSchema[TYMAImageOut]](
                data=paginated_data,
                status_code=HTTPStatusCode.OK,
                success=True,
                message="Images retrieved successfully"
            )
        except Exception as e:
            error_message = create_detailed_error_response(e, "images retrieval")
            return StandardResponseDTO[PaginatedResponseSchema[TYMAImageOut]](
                data=PaginatedResponseSchema(items=[], total=0, page=1, per_page=per_page),
                status_code=HTTPStatusCode.INTERNAL_SERVER_ERROR,
                success=False,
                message=error_message
            )

    @staticmethod
    def update_image(
        image_id: str,
        title: str = None,
        alt_text: str = None,
        caption: str = None,
        image_type: str = None
    ) -> StandardResponseDTO[TYMAImageOut]:
        """Update an existing image"""
        try:
            image = TYMAImage.objects.get(id=UUID(image_id))
            
            # Update fields if provided
            if title is not None:
                image.title = title
            if alt_text is not None:
                image.alt_text = alt_text
            if caption is not None:
                image.caption = caption
            if image_type is not None:
                valid_types = [choice[0] for choice in TYMAImage.IMAGE_TYPE_CHOICES]
                if image_type not in valid_types:
                    return StandardResponseDTO[TYMAImageOut](
                        data=None,
                        status_code=HTTPStatusCode.BAD_REQUEST,
                        success=False,
                        message=f"Invalid image type. Must be one of: {valid_types}"
                    )
                image.image_type = image_type
            
            image.save()
            
            return StandardResponseDTO[TYMAImageOut](
                data=ImageService._image_to_schema(image),
                status_code=HTTPStatusCode.OK,
                success=True,
                message="Image updated successfully"
            )
        except (ValueError, TYMAImage.DoesNotExist):
            return StandardResponseDTO[TYMAImageOut](
                data=None,
                status_code=HTTPStatusCode.NOT_FOUND,
                success=False,
                message=f"Image with ID '{image_id}' not found"
            )
        except Exception as e:
            error_message = create_detailed_error_response(e, "image update")
            return StandardResponseDTO[TYMAImageOut](
                data=None,
                status_code=HTTPStatusCode.INTERNAL_SERVER_ERROR,
                success=False,
                message=error_message
            )

    @staticmethod
    def delete_image(image_id: str) -> StandardResponseDTO[None]:
        """Delete an image"""
        try:
            image = TYMAImage.objects.get(id=UUID(image_id))
            
            # Delete the file from storage
            if image.image:
                try:
                    os.remove(image.image.path)
                except (OSError, FileNotFoundError):
                    pass  # File might already be deleted or not exist
            
            image.delete()
            
            return StandardResponseDTO[None](
                data=None,
                status_code=HTTPStatusCode.OK,
                success=True,
                message="Image deleted successfully"
            )
        except (ValueError, TYMAImage.DoesNotExist):
            return StandardResponseDTO[None](
                data=None,
                status_code=HTTPStatusCode.NOT_FOUND,
                success=False,
                message=f"Image with ID '{image_id}' not found"
            )
        except Exception as e:
            error_message = create_detailed_error_response(e, "image deletion")
            return StandardResponseDTO[None](
                data=None,
                status_code=HTTPStatusCode.INTERNAL_SERVER_ERROR,
                success=False,
                message=error_message
            )

    @staticmethod
    def link_image_to_object(
        image_id: str,
        content_type_id: int,
        object_id: str
    ) -> StandardResponseDTO[TYMAImageOut]:
        """Link an existing image to a model instance"""
        try:
            image = TYMAImage.objects.get(id=UUID(image_id))
            
            # Get content type
            try:
                content_type = ContentType.objects.get(id=content_type_id)
            except ContentType.DoesNotExist:
                return StandardResponseDTO[TYMAImageOut](
                    data=None,
                    status_code=HTTPStatusCode.BAD_REQUEST,
                    success=False,
                    message="Invalid content type ID"
                )
            
            # Update the image's generic foreign key
            image.content_type = content_type
            image.object_id = UUID(object_id)
            image.save()
            
            return StandardResponseDTO[TYMAImageOut](
                data=ImageService._image_to_schema(image),
                status_code=HTTPStatusCode.OK,
                success=True,
                message="Image linked to object successfully"
            )
        except (ValueError, TYMAImage.DoesNotExist):
            return StandardResponseDTO[TYMAImageOut](
                data=None,
                status_code=HTTPStatusCode.NOT_FOUND,
                success=False,
                message=f"Image with ID '{image_id}' not found"
            )
        except Exception as e:
            error_message = create_detailed_error_response(e, "image linking")
            return StandardResponseDTO[TYMAImageOut](
                data=None,
                status_code=HTTPStatusCode.INTERNAL_SERVER_ERROR,
                success=False,
                message=error_message
            )

    @staticmethod
    def get_images_for_object(
        content_type: str,
        object_id: str,
        image_type: str = None
    ) -> StandardResponseDTO[List[TYMAImageOut]]:
        """Get all images linked to a specific object"""
        try:
            # Get content type
            try:
                ct = ContentType.objects.get(model=content_type)
            except ContentType.DoesNotExist:
                return StandardResponseDTO[List[TYMAImageOut]](
                    data=[],
                    status_code=HTTPStatusCode.BAD_REQUEST,
                    success=False,
                    message="Invalid content type"
                )
            
            queryset = TYMAImage.objects.filter(
                content_type=ct,
                object_id=UUID(object_id)
            )
            
            if image_type:
                queryset = queryset.filter(image_type=image_type)
            
            images = [ImageService._image_to_schema(img) for img in queryset]
            
            return StandardResponseDTO[List[TYMAImageOut]](
                data=images,
                status_code=HTTPStatusCode.OK,
                success=True,
                message=f"Retrieved {len(images)} images for object"
            )
        except ValueError:
            return StandardResponseDTO[List[TYMAImageOut]](
                data=[],
                status_code=HTTPStatusCode.BAD_REQUEST,
                success=False,
                message="Invalid object ID"
            )
        except Exception as e:
            error_message = create_detailed_error_response(e, "images retrieval for object")
            return StandardResponseDTO[List[TYMAImageOut]](
                data=[],
                status_code=HTTPStatusCode.INTERNAL_SERVER_ERROR,
                success=False,
                message=error_message
            )
